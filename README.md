# SW-Lab-8 (پیمایشگر گراف)

در این پروژه، یک پیمایشگر ساده گراف با دو روش اول-سطح و اول-عمق پیاده سازی شده است.


 تلاش می‌کنیم وابستگی کلاس‌های پیمایش (DFS و BFS) به نوع خاصی از گراف (مثلاً SparseMultigraph از کتابخانه Jung) را از بین ببریم. برای این کار:

1. یک واسط (Interface) با نام Graph ایجاد کرده‌ایم.
2. یک کلاس آداپتر (GraphAdapter) نوشته‌ایم تا درخواست‌ها را از واسط Graph به کلاس اصلی SparseMultigraph هدایت کند.
3. کلاس‌های BfsGraphTraverser و DfsGraphTraverser را به‌گونه‌ای تغییر داده‌ایم که فقط به واسط Graph وابسته باشند، نه پیاده‌سازی خاص کتابخانه.
4. در کلاس Main از آداپتر استفاده می‌کنیم تا ساخت گراف و پیمایش آن انجام شود.

## 1. ایجاد واسط Graph
در ابتدا، واسطی به نام Graph تعریف می‌کنیم که نشان می‌دهد گراف ما باید چه متدهایی را ارائه دهد:

عکس از پیاده سازی گراف


- V نوع رأس‌ها (Vertices) را مشخص می‌کند (مثلاً `Integer`).
- E نوع یال‌ها (Edges) را مشخص می‌کند (مثلاً `String`).
- متدهای addVertex, addEdge و getNeighbors نیازهای اساسی ما برای کار با گراف هستند.

---

## 2. پیاده‌سازی آداپتر GraphAdapter

در این مرحله، کلاس GraphAdapter را می‌نویسیم که واسط `<Graph<Integer, String` را پیاده‌سازی می‌کند. این کلاس درون خود یک شئ از نوع  `<SparseMultigraph<Integer, String`  دارد و فراخوانی‌های واسط Graph را به آن منتقل می‌کند.

![image](https://github.com/user-attachments/assets/b4c144c2-2f1e-4457-a475-a426fde66438)


- شیء adaptee همان گراف اصلی Jung است.  
- هر متد واسط Graph را فراخوانی می‌کنیم و درخواست مربوطه را به adaptee منتقل می‌کنیم.  
- این ساختار نمونه‌ای از Object Adapter است، چون از ترکیب استفاده می‌کند (دارا بودن یک شیء از کلاس دیگر)، نه ارث‌بری.

---
## ۳. تغییر کلاس‌های پیمایش (DFS و BFS) برای استفاده از Graph

در این گام، کلاس‌های BfsGraphTraverser و DfsGraphTraverser به‌جای ارجاع مستقیم به `SparseMultigraph`، به واسط `<Graph<Integer, String` وابسته می‌شوند.

![image](https://github.com/user-attachments/assets/eb82df7e-3ccd-493e-9549-8c55a64a64cc)



با این تغییرات، هر دو کلاس تنها نیازمند واسط Graph هستند و پیاده‌سازی خاص کتابخانه را مستقیماً نمی‌بینند.

---

## ۴. استفاده از آداپتر در کلاس Main

در نهایت، در کلاس Main از GraphAdapter استفاده می‌کنیم تا شیء `<Graph<Integer, String>` را بسازیم و سپس متدهای مختلف آن را فراخوانی کنیم.

![image](https://github.com/user-attachments/assets/7b7d2f95-2728-48a9-8a6c-d26ac1ea8e01)



در اینجا دیگر کلاس Main هم کد خودش را بر اساس واسط Graph نوشته است، و داخلی‌ترین جزئیات کتابخانهٔ Jung فقط در GraphAdapter پنهان شده‌اند.

---

## ۵. چرا از روش Object Adapter استفاده کرده‌ایم و نه Class Adapter؟

<div dir="rtl">- Object Adapter (Composition): <div/>
 
  این روش (ترکیب شیئی) باعث می‌شود آداپتر ما درون خود یک شیء از کلاس اصلی (مثلاً `SparseMultigraph`) داشته باشد و عملیات را به آن بسپارد. در جاوا به‌علت نبود ارث‌بری چندگانه، استفاده از Object Adapter معمولاً مناسب‌تر است. همچنین Coupling (وابستگی) کمتری میان آداپتر و کلاس اصلی ایجاد می‌شود و تغییر یا جایگزینی کتابخانه‌های دیگر به‌سادگی انجام خواهد شد.

<div dir="rtl">- Class Adapter (Inheritance): <div/>
 
  در این روش آداپتر مستقیماً از کلاس کتابخانه (مثلاً `SparseMultigraph`) ارث‌بری می‌کند که مشکلات زیر را در پی دارد:
 
- اگر کلاس کتابخانه final باشد یا محدودیت دیگری داشته باشد، ارث‌بری ناممکن می‌شود.
- در جاوا فقط یک کلاس می‌تواند والد باشد، بنابراین انعطاف‌پذیری را کاهش می‌دهد.
- آداپتر به‌شدت به پیاده‌سازی داخلی آن کلاس کتابخانه وابسته می‌شود و تغییر آن را سخت می‌کند.

به همین دلایل، در اکثر موارد استفاده از روش Object Adapter به‌خصوص در زبان جاوا ترجیح داده می‌شود.

# استفاده از JGraphT به‌جای JUNG با الگوی طراحی Adapter

در این پروژه، قصد داشتیم کلاس‌های پیمایش (DFS و BFS) را از وابستگی به کتابخانه‌ی JUNG جدا کنیم. برای این کار از الگوی Adapter به روش Object Adapter استفاده کردیم و تمام وابستگی‌ها را در یک کلاس آداپتر متمرکز کردیم.

به‌این‌ترتیب، اگر بخواهیم کتابخانه‌ی گراف را عوض کنیم و از JGraphT استفاده کنیم، تنها کافیست کلاس Adapter را تغییر دهیم و از کتابخانه‌ی JGraphT برای عملیات گرافی استفاده کنیم.

## ۱. اینترفیس Graph

ابتدا به یاد داشته باشیم که ما یک واسط (Interface) به نام `<Graph<V, E` تعریف کرده‌ایم. این واسط نشان می‌دهد یک گراف چه متدهایی ارائه می‌کند و کلاس‌های پیمایش (Traverserها) فقط به اینترفیس زیر وابسته هستند

---
## ۲. ساخت آداپتر برای کتابخانه‌ی JGraphT

در این مثال، قصد داریم از گراف ساده (بدون جهت) `SimpleGraph` با یال‌های `DefaultEdge` استفاده کنیم. اگر به گراف جهت‌دار یا وزن‌دار نیاز دارید، می‌توانید از کلاس‌های دیگری که JGraphT ارائه می‌دهد (مانند `DefaultDirectedGraph` یا `DefaultWeightedEdge`) استفاده کنید.

<img width="789" alt="Screenshot 2025-01-12 at 8 14 23 PM" src="https://github.com/user-attachments/assets/396dc5be-3080-442d-b0cd-8961c53a30a6" />


---
# پاسخ به پرسش‌ها دربارهٔ الگوی Strategy در این پروژه

در این پروژه برای پیاده‌سازی روش‌های مختلف پیمایش (DFS و BFS)، از **الگوی Strategy** استفاده شده است. در ادامه، دلایل و نحوه‌ی تحقق این الگو به‌طور مختصر بیان می‌شود.

---

## 1. استفاده از این الگو به چه علتی قابل قبول است؟

الگوی **Strategy** امکان جداسازی منطق پیمایش (رفتار) از ساختار اصلی گراف و نحوهٔ مدیریت آن را فراهم می‌کند. بدین ترتیب، می‌توان چندین روش پیمایش (مثل BFS و DFS) را به شکل کلاس‌های مستقل پیاده‌سازی نمود و به‌سادگی در زمان اجرا یا زمان کامپایل، روش مورد نظر را جایگزین کرد. همچنین این رویکرد باعث می‌شود تغییر یا اضافه‌کردن استراتژی‌های جدید بدون دست‌بردن در کدهای دیگر صورت گیرد (اصل Open/Closed).

---

## 2. روش تحقق این الگو را به صورت مختصر و در حد سه سطر توضیح دهید

1. یک **اینترفیس** (یا کلاس انتزاعی) برای روش پیمایش طراحی شده است (مثلاً `Traverser`) که متد اصلی پیمایش (مثلاً `traverse`) را تعریف می‌کند.  
2. برای هر الگوریتم (BFS و DFS)، کلاسی مجزا ایجاد می‌شود که آن اینترفیس را پیاده‌سازی می‌کند.  
3. در کلاس اصلی (مثلاً `Main`)، از طریق سازنده یا یک Setter، **شیوهٔ پیمایش** (استراتژی) تعیین می‌گردد و بدون تغییر در مابقی کد، قابل جایگزینی است.  

