# SW-Lab-8 (پیمایشگر گراف)

در این پروژه، یک پیمایشگر ساده گراف با دو روش اول-سطح و اول-عمق پیاده سازی شده است.


 تلاش می‌کنیم وابستگی کلاس‌های پیمایش (DFS و BFS) به نوع خاصی از گراف (مثلاً SparseMultigraph از کتابخانه Jung) را از بین ببریم. برای این کار:

1. یک واسط (Interface) با نام Graph ایجاد کرده‌ایم.
2. یک کلاس آداپتر (GraphAdapter) نوشته‌ایم تا درخواست‌ها را از واسط Graph به کلاس اصلی SparseMultigraph هدایت کند.
3. کلاس‌های BfsGraphTraverser و DfsGraphTraverser را به‌گونه‌ای تغییر داده‌ایم که فقط به واسط Graph وابسته باشند، نه پیاده‌سازی خاص کتابخانه.
4. در کلاس Main از آداپتر استفاده می‌کنیم تا ساخت گراف و پیمایش آن انجام شود.

## 1. ایجاد واسط Graph
در ابتدا، واسطی به نام Graph تعریف می‌کنیم که نشان می‌دهد گراف ما باید چه متدهایی را ارائه دهد:

عکس از پیاده سازی گراف


- V نوع رأس‌ها (Vertices) را مشخص می‌کند (مثلاً `Integer`).
- E نوع یال‌ها (Edges) را مشخص می‌کند (مثلاً `String`).
- متدهای addVertex, addEdge و getNeighbors نیازهای اساسی ما برای کار با گراف هستند.

---

## 2. پیاده‌سازی آداپتر GraphAdapter

در این مرحله، کلاس GraphAdapter را می‌نویسیم که واسط <Graph<Integer, String را پیاده‌سازی می‌کند. این کلاس درون خود یک شئ از نوع <SparseMultigraph<Integer, String دارد و فراخوانی‌های واسط Graph را به آن منتقل می‌کند.

image

- شیء adaptee همان گراف اصلی Jung است.  
- هر متد واسط Graph را فراخوانی می‌کنیم و درخواست مربوطه را به adaptee منتقل می‌کنیم.  
- این ساختار نمونه‌ای از Object Adapter است، چون از ترکیب استفاده می‌کند (دارا بودن یک شیء از کلاس دیگر)، نه ارث‌بری.

---
